# LTI-JACA

## Description

LTI-ATS-JACA is a cutting-edge Applicant Tracking System designed to streamline and optimize the recruitment process for organizations of all sizes. This comprehensive solution combines intuitive user interface with powerful automation features to help HR professionals and hiring managers efficiently manage their talent acquisition pipeline. LTI-ATS-JACA aims to reduce time-to-hire, improve candidate experience, and provide valuable insights to make data-driven hiring decisions.
Basic functionalities of an ATS, listed and described in order of priority:

1. Job Posting and Distribution:
   - Create and publish job listings across multiple platforms.
   - Integrate with job boards and career sites.
   - Manage internal job postings.

2. Resume Parsing and Candidate Profile :Creation
   - Automatically extract information from resumes.
   - Create standardized candidate profiles.
   - Enable keyword search and filtering.

3. Applicant Tracking and Workflow Management:
   - Track candidate progress through hiring stages.
   - Customize hiring workflows for different positions.
   - Automate status updates and notifications.

4. Communication Tools:
   - Send automated emails to candidates.
   - Schedule interviews and send reminders.
   - Facilitate internal communication between hiring team members.

5. Interview Management:
   - Schedule and track interviews.
   - Provide interview guides and scorecards.
   - Collect and organize feedback from interviewers.

6. Candidate Evaluation and Scoring:
   - Create customizable evaluation criteria.
   - Enable collaborative scoring and ranking.
   - Generate comparison reports for decision-making.

7. Reporting and Analytics:
   - Track key recruitment metrics (e.g., time-to-hire, source of hire).
   - Generate customizable reports.
   - Provide data-driven insights for process improvement.

8. Compliance and Equal Employment :Opportunity (EEO) Tracking
   - Ensure compliance with labor laws and regulations.
   - Track and report on diversity metrics.
   - Manage required documentation for audits.

9. Integration Capabilities:
   - Connect with HRIS, payroll, and onboarding systems.
   - Integrate with background check services.
   - Enable single sign-on (SSO) for seamless user experience.

10. Mobile Accessibility:
    - Provide mobile-friendly interface for candidates and hiring managers.
    - Enable on-the-go application reviews and approvals.
    - Facilitate mobile communication and notifications.

## Added Value
1. Improved Efficiency
   - Streamlined recruitment process
   - Reduced time-to-hire
   - Automation of repetitive tasks

2. Cost Reduction
   - Lower recruitment advertising costs
   - Decreased reliance on external recruiters
   - Optimized use of HR resources

3. Enhanced Candidate Experience
   - User-friendly application process
   - Timely communication and updates
   - Mobile accessibility for on-the-go applications

4. Better Quality of Hires
   - Standardized evaluation criteria
   - Data-driven decision making
   - Improved candidate matching through AI-powered screening

5. Increased Collaboration
   - Centralized communication for hiring teams
   - Easy sharing of candidate information and feedback
   - Improved alignment between HR and hiring managers

6. Compliance and Risk Mitigation
   - Ensure adherence to labor laws and regulations
   - Standardized processes to reduce bias
   - Proper documentation for potential audits

7. Data-Driven Insights
   - Comprehensive recruitment analytics
   - Identification of best-performing sourcing channels
   - Metrics to continuously improve hiring processes

8. Scalability
   - Ability to handle high-volume recruiting
   - Adaptable to company growth and changing needs
   - Support for multiple locations or departments

9. Improved Employer Branding
   - Professional and consistent candidate communication
   - Showcase company culture through customized career pages
   - Positive candidate experience leading to better company reviews

10. Time Savings
    - Faster resume screening and shortlisting
    - Automated interview scheduling
    - Quick generation of offer letters and contracts

11. Enhanced Talent Pool Management
    - Build and maintain a database of potential candidates
    - Easy retrieval of past applicants for new positions
    - Nurture relationships with passive candidates

12. Integration Capabilities
    - Seamless connection with existing HR systems
    - Unified data flow from recruitment to onboarding
    - Reduced manual data entry and potential errors

13. Customization and Flexibility
    - Tailored workflows for different positions or departments
    - Customizable evaluation forms and interview guides
    - Adaptable reporting to meet specific organizational needs

14. Improved Decision Making
    - Side-by-side candidate comparisons
    - Historical data to inform hiring strategies
    - Predictive analytics for future hiring needs

15. Global Recruiting Support
    - Multi-language capabilities
    - Compliance with international hiring regulations
    - Support for diverse hiring practices across regions

## Targets

1. Company Size:
   a) Small Businesses (1-50 employees)
   b) Mid-size Companies (51-500 employees)
   c) Large Enterprises (500+ employees)

2. Industry Sectors:
   a) Technology and IT
   b) Healthcare and Pharmaceuticals
   c) Financial Services and Banking
   d) Retail and E-commerce
   e) Manufacturing
   f) Education
   g) Professional Services (Consulting, Legal, etc.)
   h) Non-profit Organizations

3. Geographical Regions:
   a) North America
   b) Europe
   c) Asia-Pacific
   d) Latin America
   e) Middle East and Africa

4. Hiring Volume:
   a) Low-volume recruiters (1-10 hires per month)
   b) Medium-volume recruiters (11-50 hires per month)
   c) High-volume recruiters (50+ hires per month)

5. Organizational Structure:
   a) Centralized HR departments
   b) Decentralized hiring (department-led recruitment)
   c) Staffing and recruitment agencies

6. Technology Adoption Level:
   a) Early adopters (tech-savvy organizations)
   b) Mainstream users (average technology adoption)
   c) Late adopters (traditional or risk-averse organizations)

7. Specific Hiring Needs:
   a) High-skill technical positions
   b) Executive and leadership roles
   c) Entry-level and internship programs
   d) Seasonal or temporary workforce
   e) Remote and distributed teams

8. Budget Constraints:
   a) Cost-sensitive organizations
   b) Value-oriented buyers
   c) Premium feature seekers

9. Compliance Requirements:
   a) Highly regulated industries (e.g., government, healthcare)
   b) Companies with strict data privacy needs
   c) Organizations with specific diversity and inclusion goals

10. Current ATS Status:
    a) First-time ATS buyers
    b) Organizations looking to switch from existing ATS
    c) Companies seeking to upgrade or consolidate multiple systems

## Competitors

1. Workday Recruiting

   Strengths:
   - Comprehensive HR suite integration
   - Strong analytics and reporting capabilities
   - User-friendly interface

   Weaknesses:
   - Can be complex for smaller organizations
   - Higher price point
   - May have longer implementation times

2. Greenhouse

   Strengths:
   - Excellent user experience
   - Strong focus on promoting diversity in hiring
   - Extensive integration options

   Weaknesses:
   - Can be expensive for smaller companies
   - Some users report limitations in customization
   - May lack some advanced features for enterprise-level needs

3. Lever

   Strengths:
   - Modern, intuitive interface
   - Strong collaboration tools
   - Good candidate relationship management features

   Weaknesses:
   - Limited reporting capabilities compared to some competitors
   - May lack some features for very large enterprises
   - Pricing can be high for smaller organizations

4. Taleo (Oracle)

   Strengths:
   - Robust features for large enterprises
   - Strong compliance tools
   - Extensive customization options

   Weaknesses:
   - User interface often criticized as outdated
   - Can be complex to use and set up
   - May be overkill for smaller organizations

5. SmartRecruiters

   Strengths:
   - AI-powered candidate matching
   - Strong marketplace for third-party integrations
   - Good scalability for growing companies

   Weaknesses:
   - Some users report occasional performance issues
   - Advanced features may require higher-tier plans
   - Customer support responsiveness has been criticized

6. iCIMS

   Strengths:
   - Comprehensive recruitment marketing tools
   - Strong compliance features
   - Good for high-volume recruiting

   Weaknesses:
   - Interface can be less intuitive than some competitors
   - Implementation can be complex
   - Some users report issues with system speed

7. Jobvite

   Strengths:
   - Strong social recruiting features
   - Good candidate relationship management
   - User-friendly interface

   Weaknesses:
   - Reporting capabilities may be limited for some users
   - Some advanced features only available in higher-tier plans
   - Integration with some third-party tools can be challenging

## Competitive Advantages

1. Adaptive AI-Powered Matching:
   - Advanced AI that learns from each organization's hiring patterns.
   - Continuously improving candidate matching and ranking.

2. Seamless Scalability:
   - Easily adapts from small business to enterprise-level needs.
   - No need to switch systems as the company grows.

3. Intuitive Customization Engine:
   - User-friendly interface for creating custom workflows and forms.
   - No coding required for advanced customizations.

4. Rapid Implementation Program:
   - Streamlined setup process with intelligent data migration.
   - Get up and running in days, not months.

5. Unified Communication Hub:
   - Centralized platform for all recruitment communications.
   - Integrates email, messaging, and video interviews.

6. Compliance Assurance System:
   - Built-in compliance checks for various global regulations.
   - Automatic updates to stay current with changing laws.

7. Predictive Analytics Dashboard:
   - Forecast hiring needs based on historical data and market trends.
   - Provide actionable insights to improve recruitment strategies.

8. Candidate Experience Optimizer:
   - Personalized candidate portals with real-time status updates.
   - Automated feedback collection to continuously enhance the process.

9. Flexible Pricing Model:
   - Pay-per-use option for smaller organizations or seasonal hiring.
   - Customizable feature sets to avoid overpaying for unused tools.

10. Seamless Integration Ecosystem:
    - One-click integrations with popular HR tools and job boards.
    - Open API for easy custom integrations.

11. Mobile-First Design:
    - Fully functional mobile app for both recruiters and candidates.
    - Optimized for on-the-go hiring and applying.

12. Automated Bias Detection:
    - AI-powered tools to identify and mitigate unconscious bias in job descriptions and screening processes.
    - Promote diversity and inclusion throughout the hiring process.

13. Continuous Learning Platform:
    - Built-in tutorials and best practices updated in real-time.
    - Personalized system suggestions based on user behavior.

14. Global Talent Pool Network:
    - Shared, anonymized database of candidates across LTI-ATS-JACA users.
    - Respect privacy while expanding reach for hard-to-fill positions.

15. Proactive Customer Success Program:
    - Dedicated success managers for all account tiers.
    - Regular check-ins and personalized optimization recommendations.

## Lean Canvas Diagram

```mermaid
graph TD
  subgraph "Lean Canvas: LTI-ATS-JACA"
    A[Problem<br/>1. Inefficient hiring processes<br/>2. Poor candidate experience<br/>3. Lack of data-driven insights]
    B[Solution<br/>1. AI-powered matching<br/>2. Intuitive customization<br/>3. Predictive analytics]
    C[Unique Value Proposition<br/>Adaptive AI-driven ATS<br/>that scales seamlessly<br/>and ensures compliance]
    D[Unfair Advantage<br/>Proprietary AI algorithm<br/>Rapid implementation<br/>Global talent pool network]
    E[Customer Segments<br/>1. SMBs<br/>2. Large enterprises<br/>3. Staffing agencies]
    F[Key Metrics<br/>1. User adoption rate<br/>2. Time-to-hire reduction<br/>3. Customer satisfaction]
    G[Channels<br/>1. Direct sales<br/>2. Partner network<br/>3. Content marketing]
    H[Cost Structure<br/>1. Development & maintenance<br/>2. Sales & marketing<br/>3. Customer support]
    I[Revenue Streams<br/>1. Subscription model<br/>2. Pay-per-use pricing<br/>3. Premium features]
end
```

</details>

## Functional Requirements

1. User Management
   - User registration and authentication
   - Role-based access control (e.g., admin, recruiter, hiring manager)
   - Password reset and account recovery

2. Job Requisition Management
   - Create, edit, and delete job requisitions
   - Approval workflow for job postings
   - Job template creation and management

3. Candidate Management
   - Candidate profile creation and editing
   - Resume parsing and data extraction
   - Candidate search and filtering
   - Candidate status tracking and updates

4. Application Process
   - Online job application form creation
   - Document upload (resumes, cover letters, portfolios)
   - Application status tracking for candidates

5. Screening and Assessment
   - Customizable screening questions
   - Skills assessment integration
   - AI-powered candidate ranking and matching

6. Interview Management
   - Interview scheduling and calendar integration
   - Video interview capability
   - Interview feedback collection and scoring

7. Communication
   - Email templates and bulk emailing
   - In-app messaging system
   - Automated notifications and reminders

8. Reporting and Analytics
   - Standard and custom report generation
   - Real-time dashboard with key metrics
   - Data export functionality

9. Integration Capabilities
   - API for third-party integrations
   - Job board posting integration
   - HRIS and payroll system integration

10. Compliance and EEO
    - EEO data collection and reporting
    - Compliance checklist for job postings
    - Audit trail for all system actions

11. Offer Management
    - Offer letter generation and tracking
    - E-signature integration for offer acceptance
    - Offer approval workflow

12. Career Site Management
    - Customizable career site builder
    - Job search and filtering for candidates
    - Mobile-responsive design

## Non-Functional Requirements

1. Performance
   - Page load time under 2 seconds for 95% of requests
   - Support for at least 10,000 concurrent users
   - Ability to handle 1 million job applications per month

2. Scalability
   - Horizontal scaling to accommodate growing user base
   - Ability to add new features without major system overhaul

3. Availability
   - 99.9% uptime guarantee
   - Scheduled maintenance windows with minimal disruption

4. Security
   - Data encryption at rest and in transit (minimum AES-256)
   - Regular security audits and penetration testing
   - Multi-factor authentication support

5. Compliance
   - GDPR, CCPA, and other relevant data protection regulations compliance
   - SOC 2 Type II certification
   - Regular compliance updates to meet changing regulations

6. Usability
   - Intuitive user interface requiring minimal training
   - Accessibility compliance (WCAG 2.1 level AA)
   - Support for multiple languages and locales

7. Reliability
   - Automated backups with point-in-time recovery
   - Fault-tolerant architecture with no single point of failure

8. Compatibility
   - Cross-browser support (Chrome, Firefox, Safari, Edge)
   - Mobile responsiveness for all major functions

9. Data Integrity
   - Data validation to ensure accuracy and consistency
   - Audit logs for all data changes

10. Maintainability
    - Modular architecture for easy updates and maintenance
    - Comprehensive system documentation
    - Automated testing with minimum 80% code coverage

11. Disaster Recovery
    - Recovery Time Objective (RTO) of 4 hours
    - Recovery Point Objective (RPO) of 1 hour

12. Performance Monitoring
    - Real-time system health monitoring
    - Automated alerts for performance issues

13. Interoperability
    - Support for standard data exchange formats (JSON, XML)
    - OAuth 2.0 support for secure API access

14. Customization
    - Ability to customize workflows without code changes
    - User-defined fields and forms

15. Data Retention and Archiving
    - Configurable data retention policies
    - Secure data archiving and retrieval system

## Main Use Cases

### Must Have (Critical features for launch)

1. User Management
   - Basic user registration and authentication
   - Role-based access control

```mermaid
graph TD
    A[User Management]
    A --> B(Register User)
    A --> C(Authenticate User)
    A --> D(Manage Roles)
    A --> E(Reset Password)
    
    B --> F((System))
    C --> F
    D --> F
    E --> F
    
    G((Admin)) --> B
    G --> D
    H((User)) --> C
    H --> E
```

Users can register accounts, login, and reset passwords. Administrators have additional capabilities to manage user roles and also need to login to access these functions.

2. Job Requisition Management
   - Create, edit, and post job requisitions
   - Basic approval workflow

```mermaid
graph TD
    A[Job Requisition Management]
    A --> B(Create Job Requisition)
    A --> C(Edit Job Requisition)
    A --> D(Post Job Requisition)
    A --> E(Approve Job Requisition)
    
    B --> F((System))
    C --> F
    D --> F
    E --> F
    
    G((Recruiter)) --> B
    G --> C
    G --> D
    H((Hiring Manager)) --> E
```

Recruiters can create, edit, and post job requisitions, while Hiring Managers can approve requisitions and also have the ability to edit them if necessary.

3. Candidate Management
   - Candidate profile creation
   - Resume parsing and data extraction
   - Basic candidate search and filtering

```mermaid
graph TD
    A[Candidate Management]
    A --> B(Create Candidate Profile)
    A --> C(Parse Resume)
    A --> D(Search Candidates)
    A --> E(Filter Candidates)
    
    B --> F((System))
    C --> F
    D --> F
    E --> F
    
    G((Recruiter)) --> B
    G --> D
    G --> E
    H((Candidate)) --> B
```

Recruiters can create candidate profiles, search, and filter candidates. The system automatically parses resumes when a candidate profile is created.

4. Application Process
   - Online job application form
   - Document upload (resumes, cover letters)

```mermaid
graph TD
    A[Application Process]
    A --> B(Submit Application)
    A --> C(Upload Documents)
    A --> D(Review Application)
    
    B --> E((System))
    C --> E
    D --> E
    
    F((Candidate)) --> B
    F --> C
    G((Recruiter)) --> D
```

Candidates can fill out application forms, upload documents, and submit applications. Once submitted, the system processes the application automatically.

5. Screening and Assessment
   - Basic screening questions
   - AI-powered candidate ranking

```mermaid
graph TD
    A[Screening and Assessment]
    A --> B(Create Screening Questions)
    A --> C(Answer Screening Questions)
    A --> D(Rank Candidates)
    
    B --> E((System))
    C --> E
    D --> E
    
    F((Recruiter)) --> B
    G((Candidate)) --> C
    H((AI)) --> D
```

Recruiters set screening questions, candidates answer them, and the system automatically ranks candidates based on their responses.

6. Interview Management
   - Interview scheduling
   - Basic feedback collection

```mermaid
graph TD
    A[Interview Management]
    A --> B(Schedule Interview)
    A --> C(Conduct Interview)
    A --> D(Provide Feedback)
    
    B --> E((System))
    C --> E
    D --> E
    
    F((Recruiter)) --> B
    G((Interviewer)) --> C
    G --> D
    H((Candidate)) --> C
```

Recruiters schedule interviews, while interviewers conduct interviews and provide feedback.

7. Communication
   - Email templates and notifications
   - Automated status updates

```mermaid
graph TD
    A[Communication]
    A --> B(Create Email Template)
    A --> C(Send Notification)
    A --> D(Update Application Status)
    
    B --> E((System))
    C --> E
    D --> E
    
    F((Recruiter)) --> B
    F --> C
    F --> D
    G((Candidate)) --> C
```

Recruiters can create email templates and update application statuses. The system sends automated notifications, which are received by candidates.

8. Reporting and Analytics
   - Standard reports on key metrics
   - Basic dashboard

```mermaid
graph TD
    A[Reporting and Analytics]
    A --> B(Generate Standard Report)
    A --> C(View Dashboard)
    A --> D(Export Data)
    
    B --> E((System))
    C --> E
    D --> E
    
    F((Recruiter)) --> B
    F --> C
    F --> D
    G((Hiring Manager)) --> C
```

Both recruiters and hiring managers can view dashboards, while recruiters can also generate standard reports and export data.

9. Compliance and EEO
   - EEO data collection
   - Basic compliance checklist

```mermaid
graph TD
    A[Compliance and EEO]
    A --> B(Collect EEO Data)
    A --> C(Generate EEO Report)
    A --> D(Verify Compliance Checklist)
    
    B --> E((System))
    C --> E
    D --> E
    
    F((Candidate)) --> B
    G((Recruiter)) --> C
    G --> D
```

The system collects EEO data from candidates, recruiters can generate EEO reports and verify job posting compliance.

10. Security and Data Protection
    - Data encryption
    - Compliance with basic data protection regulations

```mermaid
graph TD
    A[Security and Data Protection]
    A --> B(Encrypt Data)
    A --> C(Manage User Permissions)
    A --> D(Perform Security Audit)
    A --> E(Implement Data Protection Policies)
    A --> F(Monitor System Access)
    
    B --> G((System))
    C --> G
    D --> G
    E --> G
    F --> G
    
    H((Admin)) --> C
    H --> D
    H --> E
    I((User)) --> G
    J((Security Officer)) --> D
    J --> F
```

The system is responsible for encrypting data and implementing data protection policies. Admins manage user permissions and implement data protection policies. Security officers perform security audits and monitor system access. All users interact with the system, which applies these security measures to protect their data and actions.

### Should Have (Important features for competitive advantage)

1. Integration Capabilities
   - API for third-party integrations
   - Job board posting integration

2. Career Site Management
   - Basic customizable career site

3. Offer Management
   - Offer letter generation and tracking

4. Advanced Screening and Assessment
   - Skills assessment integration
   - More advanced AI matching algorithms

5. Video Interview Capability

6. Mobile-Responsive Design

7. Customizable Workflows

8. Advanced Search and Filtering Options

9. Candidate Status Tracking and Updates

10. Bulk Actions for Candidate Management

### Could Have (Desirable features to enhance the product)

1. Advanced Reporting and Analytics
   - Custom report generation
   - Predictive analytics

2. Talent Pool Management

3. Employee Referral Management

4. Advanced Career Site Builder

5. Automated Reference Checking

6. Social Media Integration for Candidate Sourcing

7. Customizable Onboarding Checklist

8. Candidate Relationship Management (CRM) Features

9. Advanced Compliance Tools
   - Global compliance support
   - Audit trail for all actions

10. AI-Powered Chatbot for Candidate Queries

### Won't Have (for initial release, may consider for future versions)

1. Full HRIS Integration

2. Payroll System Integration

3. Advanced Succession Planning Tools

4. Employee Performance Management

5. Learning Management System (LMS) Integration

6. Advanced Employer Branding Tools

7. Recruitment Marketing Automation

8. Vendor Management System for Staffing Agencies

9. Internal Mobility and Career Pathing Tools

10. AI-Powered Interview Scheduling and Optimization

## Data Model

### Diagram

```mermaid
erDiagram
    User ||--o{ JobRequisition : "creates"
    User ||--o{ Candidate : "manages"
    User ||--o{ Interview : "schedules"
    User {
        int user_id PK
        string username
        string email
        string password_hash
        string role
        datetime created_at
        datetime last_login
    }
    
    JobRequisition ||--o{ Application : "receives"
    JobRequisition {
        int job_id PK
        string title
        text description
        string status
        int created_by FK
        datetime created_at
        datetime posted_at
    }
    
    Candidate ||--o{ Application : "submits"
    Candidate {
        int candidate_id PK
        string first_name
        string last_name
        string email
        text resume
        datetime created_at
    }
    
    Application ||--o{ Interview : "leads to"
    Application {
        int application_id PK
        int job_id FK
        int candidate_id FK
        string status
        datetime applied_at
    }
    
    Interview {
        int interview_id PK
        int application_id FK
        int interviewer_id FK
        datetime scheduled_at
        string status
        text feedback
    }
    
    ScreeningQuestion ||--o{ JobRequisition : "belongs to"
    ScreeningQuestion {
        int question_id PK
        int job_id FK
        text question
        string question_type
    }
    
    Communication {
        int communication_id PK
        int user_id FK
        int candidate_id FK
        string type
        text content
        datetime sent_at
    }
    
    Report {
        int report_id PK
        string report_name
        string report_type
        json parameters
        datetime generated_at
    }
    
    EEOData ||--o{ Candidate : "belongs to"
    EEOData {
        int eeo_id PK
        int candidate_id FK
        string gender
        string ethnicity
        string veteran_status
        string disability_status
    }
```

### Description

1. User: Represents system users (recruiters, hiring managers, admins).
2. JobRequisition: Stores information about job openings.
3. Candidate: Contains details of job applicants.
4. Application: Represents a candidate's application for a specific job.
5. Interview: Stores interview details for applications.
6. ScreeningQuestion: Contains screening questions associated with job requisitions.
7. Communication: Tracks all communications with candidates.
8. Report: Stores generated reports.
9. EEOData: Contains Equal Employment Opportunity data for candidates.

### Relationships

- Users create JobRequisitions and manage Candidates.
- JobRequisitions receive multiple Applications.
- Candidates submit multiple Applications.
- Applications can lead to multiple Interviews.
- ScreeningQuestions belong to JobRequisitions.
- EEOData belongs to Candidates.

## Architecture

### Tech Stack

1. Frontend: React.js with TypeScript
2. Backend: Node.js with Express.js
3. Database: PostgreSQL
4. Caching: Redis
5. Search Engine: Elasticsearch
6. Message Queue: RabbitMQ
7. Container Orchestration: Kubernetes
8. CI/CD: GitLab CI/CD
9. Monitoring: Prometheus and Grafana
10. Logging: ELK Stack (Elasticsearch, Logstash, Kibana)
11. API Gateway: Kong
12. Authentication: OAuth 2.0 with JSON Web Tokens (JWT)
13. Cloud Provider: AWS

### Diagram

```mermaid
graph TD
    subgraph Client
        A[Web Browser]
        B[Mobile App]
    end

    C[CDN: CloudFront]
    D[Load Balancer: ELB]
    E[API Gateway: Kong]
    F[Web Server: Nginx]

    subgraph "Application Servers"
        G[Node.js + Express]
    end

    H[Authentication: OAuth 2.0 / JWT]
    I[Message Queue: RabbitMQ]
    J[Caching: Redis]
    K[Search Engine: Elasticsearch]
    L[Database: PostgreSQL]
    M[Storage: S3]

    subgraph "Monitoring & Logging"
        N[Prometheus]
        O[Grafana]
        P[ELK Stack]
    end

    Q[CI/CD: GitLab CI/CD]
    R[Container Orchestration: Kubernetes]

    A --> C
    B --> C
    C --> D
    D --> E
    E --> F
    F --> G
    G --> H
    G --> I
    G --> J
    G --> K
    G --> L
    G --> M
    G -.-> N
    G -.-> O
    G -.-> P
    Q -.-> R
    R --> G
```

### Description

1. Client Layer: Users interact with the system through web browsers or mobile apps. The frontend is built with React.js and TypeScript for a responsive and type-safe user interface.
2. Content Delivery Network (CDN): AWS CloudFront is used to serve static assets globally, reducing latency for users.
3. Load Balancer: AWS Elastic Load Balancing distributes incoming traffic across multiple instances of the application servers.
4. API Gateway: Kong serves as the API gateway, handling routing, rate limiting, and API versioning.
5. Web Server: Nginx acts as a reverse proxy and handles SSL termination.
6. Application Servers: Node.js with Express.js powers the backend, running in containers orchestrated by Kubernetes for scalability and easy management.
7. Authentication: OAuth 2.0 with JWT is used for secure authentication and authorization.
8. Message Queue: RabbitMQ handles asynchronous tasks and ensures system resilience.
9. Caching: Redis is used for caching frequently accessed data, improving performance.
10. Search Engine: Elasticsearch provides fast and efficient full-text search capabilities.
11. Databases: PostgreSQL serves as the primary relational database for structured data storage.
12. Storage: AWS S3 is used for storing files such as resumes and other documents.
13. Monitoring & Logging: Prometheus and Grafana are used for real-time monitoring and visualization of system metrics. The ELK Stack (Elasticsearch, Logstash, Kibana) is used for centralized logging and log analysis.
14. CI/CD: GitLab CI/CD is used for continuous integration and deployment, automating the build, test, and deployment processes.
15. Container Orchestration: Kubernetes manages the deployment, scaling, and operations of application containers across clusters of hosts.

This architecture is designed to be scalable, resilient, and maintainable. It leverages cloud services (AWS) for infrastructure, uses containers for consistency across environments, and implements modern DevOps practices for efficient development and operations.

The system is built with microservices architecture in mind, allowing for independent scaling and development of different components. The use of message queues and caching helps in handling high loads and improving response times. The inclusion of monitoring and logging systems ensures that the operations team can quickly identify and resolve any issues that arise.

## C4

### Context

```mermaid
graph TB
    subgraph lb[LTI-ATS-JACA]
        ltiAtsJaca[Applicant Tracking System]
    end
    
    candidate[Candidate]
    recruiter[Recruiter]
    hiringManager[Hiring Manager]
    emailSystem[Email System]
    jobBoards[Job Boards]
    
    candidate -->|Submits applications, views job listings| ltiAtsJaca
    recruiter -->|Manages job postings, reviews applications, schedules interviews| ltiAtsJaca
    hiringManager -->|Reviews candidates, provides feedback| ltiAtsJaca
    ltiAtsJaca -->|Sends notifications| emailSystem
    ltiAtsJaca -->|Posts job listings| jobBoards
    
    class candidate,recruiter,hiringManager person
    class emailSystem,jobBoards external_system
    class lb system_boundary
    
    classDef person fill:#08427B
    classDef external_system fill:#999999
    classDef system_boundary fill:#ffffff,stroke:#444444,stroke-width:2px,stroke-dasharray: 5 5
```

### Container

```mermaid
graph TB
    subgraph lb[LTI-ATS-JACA]
        webApp[Web Application<br/>React, TypeScript]
        mobileApp[Mobile App<br/>React Native]
        apiGateway[API Gateway<br/>Kong]
        appServer[Application Server<br/>Node.js, Express]
        database[(Database<br/>PostgreSQL)]
        searchEngine[Search Engine<br/>Elasticsearch]
        cacheLayer[Cache<br/>Redis]
        messageQueue[Message Queue<br/>RabbitMQ]
    end
    
    candidate[Candidate]
    recruiter[Recruiter]
    hiringManager[Hiring Manager]
    emailSystem[Email System]
    jobBoards[Job Boards]
    
    candidate -->|Uses| webApp
    candidate -->|Uses| mobileApp
    recruiter -->|Uses| webApp
    hiringManager -->|Uses| webApp
    
    webApp -->|Makes API calls to| apiGateway
    mobileApp -->|Makes API calls to| apiGateway
    apiGateway -->|Routes requests to| appServer
    
    appServer -->|Reads from and writes to| database
    appServer -->|Reads from and writes to| searchEngine
    appServer -->|Reads from and writes to| cacheLayer
    appServer -->|Publishes messages to| messageQueue
    
    appServer -->|Sends emails using| emailSystem
    appServer -->|Posts jobs to| jobBoards
    
    class candidate,recruiter,hiringManager person
    class emailSystem,jobBoards external_system
    class lb system_boundary
    class webApp,mobileApp,apiGateway,appServer,database,searchEngine,cacheLayer,messageQueue container
    
    classDef person fill:#08427B
    classDef external_system fill:#999999
    classDef system_boundary fill:#ffffff,stroke:#444444,stroke-width:2px,stroke-dasharray: 5 5
    classDef container fill:#438DD5
```

### Component

#### Application Server

```mermaid
graph TB
    subgraph lb[Application Server]
        userController[User Controller<br/>Express.js]
        jobController[Job Controller<br/>Express.js]
        applicationController[Application Controller<br/>Express.js]
        interviewController[Interview Controller<br/>Express.js]
        authService[Auth Service<br/>Node.js]
        searchService[Search Service<br/>Node.js]
        emailService[Email Service<br/>Node.js]
        jobBoardService[Job Board Service<br/>Node.js]
    end
    
    apiGateway[API Gateway<br/>Kong]
    database[(Database<br/>PostgreSQL)]
    searchEngine[Search Engine<br/>Elasticsearch]
    cacheLayer[Cache<br/>Redis]
    messageQueue[Message Queue<br/>RabbitMQ]
    emailSystem[Email System]
    jobBoards[Job Boards]
    
    apiGateway -->|Routes requests to| userController
    apiGateway -->|Routes requests to| jobController
    apiGateway -->|Routes requests to| applicationController
    apiGateway -->|Routes requests to| interviewController
    
    userController --> authService
    jobController --> authService
    applicationController --> authService
    interviewController --> authService
    
    jobController --> searchService
    applicationController --> searchService
    
    userController --> emailService
    jobController --> emailService
    applicationController --> emailService
    interviewController --> emailService
    
    jobController --> jobBoardService
    
    authService -->|Reads from and writes to| database
    userController -->|Reads from and writes to| database
    jobController -->|Reads from and writes to| database
    applicationController -->|Reads from and writes to| database
    interviewController -->|Reads from and writes to| database
    
    searchService -->|Reads from and writes to| searchEngine
    authService -->|Reads from and writes to| cacheLayer
    emailService -->|Publishes messages to| messageQueue
    
    emailService -->|Sends emails using| emailSystem
    jobBoardService -->|Posts jobs to| jobBoards
    
    class apiGateway,database,searchEngine,cacheLayer,messageQueue,emailSystem,jobBoards external_component
    class lb system_boundary
    class userController,jobController,applicationController,interviewController,authService,searchService,emailService,jobBoardService component
    
    classDef external_component fill:#999999
    classDef system_boundary fill:#ffffff,stroke:#444444,stroke-width:2px,stroke-dasharray: 5 5
    classDef component fill:#85BBF0
```

### Code

#### Job Controller

##### Interaction Diagram

```mermaid
graph TD
    A[Client] -->|HTTP Request| B[Job Controller]
    B -->|Query/Update| C[Job Service]
    C -->|CRUD Operations| D[Job Repository]
    D -->|Database Operations| E[(Database)]
```

##### Sequence Diagram

```mermaid
sequenceDiagram
    participant C as Client
    participant JC as JobController
    participant JS as JobService
    participant JR as JobRepository
    participant DB as Database

    C->>JC: POST /jobs (Create Job)
    JC->>JS: createJob(jobDTO)
    JS->>JR: save(job)
    JR->>DB: INSERT INTO jobs
    DB-->>JR: Job Created
    JR-->>JS: Job Object
    JS-->>JC: JobDTO
    JC-->>C: 201 Created (JobDTO)

    C->>JC: GET /jobs/{id} (Get Job)
    JC->>JS: getJob(id)
    JS->>JR: findById(id)
    JR->>DB: SELECT FROM jobs
    DB-->>JR: Job Data
    JR-->>JS: Job Object
    JS-->>JC: JobDTO
    JC-->>C: 200 OK (JobDTO)
```

##### Class Diagram

```mermaid
classDiagram
    class JobController {
        -JobService jobService
        +createJob(JobDTO) : ResponseEntity
        +getJob(Long) : ResponseEntity
        +updateJob(Long, JobDTO) : ResponseEntity
        +deleteJob(Long) : ResponseEntity
        +listJobs(Pageable) : ResponseEntity
    }
    class JobService {
        -JobRepository jobRepository
        +createJob(JobDTO) : JobDTO
        +getJob(Long) : JobDTO
        +updateJob(Long, JobDTO) : JobDTO
        +deleteJob(Long) : void
        +listJobs(Pageable) : Page<JobDTO>
    }
    class JobRepository {
        +save(Job) : Job
        +findById(Long) : Optional<Job>
        +delete(Job) : void
        +findAll(Pageable) : Page<Job>
    }
    class Job {
        -Long id
        -String title
        -String description
        -JobStatus status
        -Date createdAt
        -Date updatedAt
    }
    class JobDTO {
        +Long id
        +String title
        +String description
        +JobStatus status
        +Date createdAt
        +Date updatedAt
    }

    JobController --> JobService
    JobService --> JobRepository
    JobRepository --> Job
    JobService --> JobDTO
```

#### Application Controller

##### Interaction Diagram

```mermaid
graph TD
    A[Client] -->|HTTP Request| B[Application Controller]
    B -->|Query/Update| C[Application Service]
    C -->|CRUD Operations| D[Application Repository]
    D -->|Database Operations| E[(Database)]
```

##### Sequence Diagram

```mermaid
sequenceDiagram
    participant C as Client
    participant AC as ApplicationController
    participant AS as ApplicationService
    participant AR as ApplicationRepository
    participant DB as Database

    C->>AC: POST /applications (Submit Application)
    AC->>AS: submitApplication(applicationDTO)
    AS->>AR: save(application)
    AR->>DB: INSERT INTO applications
    DB-->>AR: Application Created
    AR-->>AS: Application Object
    AS-->>AC: ApplicationDTO
    AC-->>C: 201 Created (ApplicationDTO)

    C->>AC: GET /applications/{id} (Get Application)
    AC->>AS: getApplication(id)
    AS->>AR: findById(id)
    AR->>DB: SELECT FROM applications
    DB-->>AR: Application Data
    AR-->>AS: Application Object
    AS-->>AC: ApplicationDTO
    AC-->>C: 200 OK (ApplicationDTO)
```

##### Class Diagram

```mermaid
classDiagram
    class ApplicationController {
        -ApplicationService applicationService
        +submitApplication(ApplicationDTO) : ResponseEntity
        +getApplication(Long) : ResponseEntity
        +updateApplication(Long, ApplicationDTO) : ResponseEntity
        +deleteApplication(Long) : ResponseEntity
        +listApplications(Pageable) : ResponseEntity
    }
    class ApplicationService {
        -ApplicationRepository applicationRepository
        +submitApplication(ApplicationDTO) : ApplicationDTO
        +getApplication(Long) : ApplicationDTO
        +updateApplication(Long, ApplicationDTO) : ApplicationDTO
        +deleteApplication(Long) : void
        +listApplications(Pageable) : Page<ApplicationDTO>
    }
    class ApplicationRepository {
        +save(Application) : Application
        +findById(Long) : Optional<Application>
        +delete(Application) : void
        +findAll(Pageable) : Page<Application>
    }
    class Application {
        -Long id
        -Long jobId
        -Long candidateId
        -ApplicationStatus status
        -Date appliedAt
    }
    class ApplicationDTO {
        +Long id
        +Long jobId
        +Long candidateId
        +ApplicationStatus status
        +Date appliedAt
    }

    ApplicationController --> ApplicationService
    ApplicationService --> ApplicationRepository
    ApplicationRepository --> Application
    ApplicationService --> ApplicationDTO
```

#### Interview Controller

##### Interaction Diagram

```mermaid
graph TD
    A[Client] -->|HTTP Request| B[Interview Controller]
    B -->|Query/Update| C[Interview Service]
    C -->|CRUD Operations| D[Interview Repository]
    D -->|Database Operations| E[(Database)]
```

##### Sequence Diagram

```mermaid
sequenceDiagram
    participant C as Client
    participant IC as InterviewController
    participant IS as InterviewService
    participant IR as InterviewRepository
    participant DB as Database

    C->>IC: POST /interviews (Schedule Interview)
    IC->>IS: scheduleInterview(interviewDTO)
    IS->>IR: save(interview)
    IR->>DB: INSERT INTO interviews
    DB-->>IR: Interview Scheduled
    IR-->>IS: Interview Object
    IS-->>IC: InterviewDTO
    IC-->>C: 201 Created (InterviewDTO)

    C->>IC: GET /interviews/{id} (Get Interview)
    IC->>IS: getInterview(id)
    IS->>IR: findById(id)
    IR->>DB: SELECT FROM interviews
    DB-->>IR: Interview Data
    IR-->>IS: Interview Object
    IS-->>IC: InterviewDTO
    IC-->>C: 200 OK (InterviewDTO)
```

##### Class Diagram

```mermaid
classDiagram
    class InterviewController {
        -InterviewService interviewService
        +scheduleInterview(InterviewDTO) : ResponseEntity
        +getInterview(Long) : ResponseEntity
        +updateInterview(Long, InterviewDTO) : ResponseEntity
        +cancelInterview(Long) : ResponseEntity
        +listInterviews(Pageable) : ResponseEntity
    }
    class InterviewService {
        -InterviewRepository interviewRepository
        +scheduleInterview(InterviewDTO) : InterviewDTO
        +getInterview(Long) : InterviewDTO
        +updateInterview(Long, InterviewDTO) : InterviewDTO
        +cancelInterview(Long) : void
        +listInterviews(Pageable) : Page<InterviewDTO>
    }
    class InterviewRepository {
        +save(Interview) : Interview
        +findById(Long) : Optional<Interview>
        +delete(Interview) : void
        +findAll(Pageable) : Page<Interview>
    }
    class Interview {
        -Long id
        -Long applicationId
        -Long interviewerId
        -Date scheduledAt
        -InterviewStatus status
        -String feedback
    }
    class InterviewDTO {
        +Long id
        +Long applicationId
        +Long interviewerId
        +Date scheduledAt
        +InterviewStatus status
        +String feedback
    }

    InterviewController --> InterviewService
    InterviewService --> InterviewRepository
    InterviewRepository --> Interview
    InterviewService --> InterviewDTO
```

#### User Controller

##### Interaction Diagram

```mermaid
graph TD
    A[Client] -->|HTTP Request| B[User Controller]
    B -->|Query/Update| C[User Service]
    C -->|CRUD Operations| D[User Repository]
    D -->|Database Operations| E[(Database)]
```

##### Sequence Diagram

```mermaid
sequenceDiagram
    participant C as Client
    participant UC as UserController
    participant US as UserService
    participant UR as UserRepository
    participant DB as Database

    C->>UC: POST /users (Create User)
    UC->>US: createUser(userDTO)
    US->>UR: save(user)
    UR->>DB: INSERT INTO users
    DB-->>UR: User Created
    UR-->>US: User Object
    US-->>UC: UserDTO
    UC-->>C: 201 Created (UserDTO)

    C->>UC: GET /users/{id} (Get User)
    UC->>US: getUser(id)
    US->>UR: findById(id)
    UR->>DB: SELECT FROM users
    DB-->>UR: User Data
    UR-->>US: User Object
    US-->>UC: UserDTO
    UC-->>C: 200 OK (UserDTO)
```

##### Class Diagram

```mermaid
classDiagram
    class UserController {
        -UserService userService
        +createUser(UserDTO) : ResponseEntity
        +getUser(Long) : ResponseEntity
        +updateUser(Long, UserDTO) : ResponseEntity
        +deleteUser(Long) : ResponseEntity
        +listUsers(Pageable) : ResponseEntity
    }
    class UserService {
        -UserRepository userRepository
        +createUser(UserDTO) : UserDTO
        +getUser(Long) : UserDTO
        +updateUser(Long, UserDTO) : UserDTO
        +deleteUser(Long) : void
        +listUsers(Pageable) : Page<UserDTO>
    }
    class UserRepository {
        +save(User) : User
        +findById(Long) : Optional<User>
        +delete(User) : void
        +findAll(Pageable) : Page<User>
    }
    class User {
        -Long id
        -String username
        -String email
        -String passwordHash
        -UserRole role
        -Date createdAt
        -Date lastLogin
    }
    class UserDTO {
        +Long id
        +String username
        +String email
        +UserRole role
        +Date createdAt
        +Date lastLogin
    }

    UserController --> UserService
    UserService --> UserRepository
    UserRepository --> User
    UserService --> UserDTO
```